{"service_job_id":27647662,"service_name":"travis-ci","source_files":[{"name":"OCMock/NSInvocation+OCMAdditions.m","source":"/*\n *  Copyright (c) 2006-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import \"NSInvocation+OCMAdditions.h\"\n#import \"OCMFunctions.h\"\n\n\n@implementation NSInvocation(OCMAdditions)\n\n- (id)getArgumentAtIndexAsObject:(int)argIndex\n{\n\tconst char *argType = OCMTypeWithoutQualifiers([[self methodSignature] getArgumentTypeAtIndex:argIndex]);\n\n\tif((strlen(argType) > 1) && (strchr(\"{^\", argType[0]) == NULL) && (strcmp(\"@?\", argType) != 0))\n\t\t[NSException raise:NSInvalidArgumentException format:@\"Cannot handle argument type '%s'.\", argType];\n\t\n\tswitch (argType[0]) \n\t{\n\t\tcase '#':\n\t\tcase '@': \n\t\t{\n\t\t\tid value;\n\t\t\t[self getArgument:&value atIndex:argIndex];\n\t\t\treturn value;\n\t\t}\n\t\tcase ':':\n \t\t{\n \t\t\tSEL s = (SEL)0;\n \t\t\t[self getArgument:&s atIndex:argIndex];\n            return [NSValue valueWithBytes:&s objCType:\":\"];\n \t\t}\n\t\tcase 'i': \n\t\t{\n\t\t\tint value;\n\t\t\t[self getArgument:&value atIndex:argIndex];\n\t\t\treturn [NSNumber numberWithInt:value];\n\t\t}\t\n\t\tcase 's':\n\t\t{\n\t\t\tshort value;\n\t\t\t[self getArgument:&value atIndex:argIndex];\n\t\t\treturn [NSNumber numberWithShort:value];\n\t\t}\t\n\t\tcase 'l':\n\t\t{\n\t\t\tlong value;\n\t\t\t[self getArgument:&value atIndex:argIndex];\n\t\t\treturn [NSNumber numberWithLong:value];\n\t\t}\t\n\t\tcase 'q':\n\t\t{\n\t\t\tlong long value;\n\t\t\t[self getArgument:&value atIndex:argIndex];\n\t\t\treturn [NSNumber numberWithLongLong:value];\n\t\t}\t\n\t\tcase 'c':\n\t\t{\n\t\t\tchar value;\n\t\t\t[self getArgument:&value atIndex:argIndex];\n\t\t\treturn [NSNumber numberWithChar:value];\n\t\t}\t\n\t\tcase 'C':\n\t\t{\n\t\t\tunsigned char value;\n\t\t\t[self getArgument:&value atIndex:argIndex];\n\t\t\treturn [NSNumber numberWithUnsignedChar:value];\n\t\t}\t\n\t\tcase 'I':\n\t\t{\n\t\t\tunsigned int value;\n\t\t\t[self getArgument:&value atIndex:argIndex];\n\t\t\treturn [NSNumber numberWithUnsignedInt:value];\n\t\t}\t\n\t\tcase 'S':\n\t\t{\n\t\t\tunsigned short value;\n\t\t\t[self getArgument:&value atIndex:argIndex];\n\t\t\treturn [NSNumber numberWithUnsignedShort:value];\n\t\t}\t\n\t\tcase 'L':\n\t\t{\n\t\t\tunsigned long value;\n\t\t\t[self getArgument:&value atIndex:argIndex];\n\t\t\treturn [NSNumber numberWithUnsignedLong:value];\n\t\t}\t\n\t\tcase 'Q':\n\t\t{\n\t\t\tunsigned long long value;\n\t\t\t[self getArgument:&value atIndex:argIndex];\n\t\t\treturn [NSNumber numberWithUnsignedLongLong:value];\n\t\t}\t\n\t\tcase 'f':\n\t\t{\n\t\t\tfloat value;\n\t\t\t[self getArgument:&value atIndex:argIndex];\n\t\t\treturn [NSNumber numberWithFloat:value];\n\t\t}\t\n\t\tcase 'd':\n\t\t{\n\t\t\tdouble value;\n\t\t\t[self getArgument:&value atIndex:argIndex];\n\t\t\treturn [NSNumber numberWithDouble:value];\n\t\t}\t\n\t\tcase 'D':\n\t\t{\n\t\t\tlong double value;\n\t\t\t[self getArgument:&value atIndex:argIndex];\n\t\t\treturn [NSValue valueWithBytes:&value objCType:@encode(typeof(value))];\n\t\t}\n\t\tcase 'B':\n\t\t{\n\t\t\tbool value;\n\t\t\t[self getArgument:&value atIndex:argIndex];\n\t\t\treturn [NSNumber numberWithBool:value];\n\t\t}\n\t\tcase '^':\n        {\n            void *value = NULL;\n            [self getArgument:&value atIndex:argIndex];\n            return [NSValue valueWithPointer:value];\n        }\n\t\tcase '{': // structure\n\t\t{\n\t\t\tNSUInteger argSize;\n\t\t\tNSGetSizeAndAlignment([[self methodSignature] getArgumentTypeAtIndex:argIndex], &argSize, NULL);\n\t\t\tif(argSize == 0) // TODO: Can this happen? Is frameLength a good choice in that case?\n                argSize = [[self methodSignature] frameLength];\n\t\t\tNSMutableData *argumentData = [[[NSMutableData alloc] initWithLength:argSize] autorelease];\n\t\t\t[self getArgument:[argumentData mutableBytes] atIndex:argIndex];\n\t\t\treturn [NSValue valueWithBytes:[argumentData bytes] objCType:argType];\n\t\t}       \n\t\t\t\n\t}\n\t[NSException raise:NSInvalidArgumentException format:@\"Argument type '%s' not supported\", argType];\n\treturn nil;\n}\n\n- (NSString *)invocationDescription\n{\n\tNSMethodSignature *methodSignature = [self methodSignature];\n\tNSUInteger numberOfArgs = [methodSignature numberOfArguments];\n\t\n\tif (numberOfArgs == 2)\n\t\treturn NSStringFromSelector([self selector]);\n\t\n\tNSArray *selectorParts = [NSStringFromSelector([self selector]) componentsSeparatedByString:@\":\"];\n\tNSMutableString *description = [[NSMutableString alloc] init];\n\tunsigned int i;\n\tfor(i = 2; i < numberOfArgs; i++)\n\t{\n\t\t[description appendFormat:@\"%@%@:\", (i > 2 ? @\" \" : @\"\"), [selectorParts objectAtIndex:(i - 2)]];\n\t\t[description appendString:[self argumentDescriptionAtIndex:i]];\n\t}\n\t\n\treturn [description autorelease];\n}\n\n- (NSString *)argumentDescriptionAtIndex:(int)argIndex\n{\n\tconst char *argType = OCMTypeWithoutQualifiers([[self methodSignature] getArgumentTypeAtIndex:argIndex]);\n\n\tswitch(*argType)\n\t{\n\t\tcase '@':\treturn [self objectDescriptionAtIndex:argIndex];\n\t\tcase 'B':\treturn [self boolDescriptionAtIndex:argIndex];\n\t\tcase 'c':\treturn [self charDescriptionAtIndex:argIndex];\n\t\tcase 'C':\treturn [self unsignedCharDescriptionAtIndex:argIndex];\n\t\tcase 'i':\treturn [self intDescriptionAtIndex:argIndex];\n\t\tcase 'I':\treturn [self unsignedIntDescriptionAtIndex:argIndex];\n\t\tcase 's':\treturn [self shortDescriptionAtIndex:argIndex];\n\t\tcase 'S':\treturn [self unsignedShortDescriptionAtIndex:argIndex];\n\t\tcase 'l':\treturn [self longDescriptionAtIndex:argIndex];\n\t\tcase 'L':\treturn [self unsignedLongDescriptionAtIndex:argIndex];\n\t\tcase 'q':\treturn [self longLongDescriptionAtIndex:argIndex];\n\t\tcase 'Q':\treturn [self unsignedLongLongDescriptionAtIndex:argIndex];\n\t\tcase 'd':\treturn [self doubleDescriptionAtIndex:argIndex];\n\t\tcase 'f':\treturn [self floatDescriptionAtIndex:argIndex];\n\t\tcase 'D':\treturn [self longDoubleDescriptionAtIndex:argIndex];\n\t\tcase '{':\treturn [self structDescriptionAtIndex:argIndex];\n\t\tcase '^':\treturn [self pointerDescriptionAtIndex:argIndex];\n\t\tcase '*':\treturn [self cStringDescriptionAtIndex:argIndex];\n\t\tcase ':':\treturn [self selectorDescriptionAtIndex:argIndex];\n\t\tdefault:\treturn [@\"<??\" stringByAppendingString:@\">\"];  // avoid confusion with trigraphs...\n\t}\n\t\n}\n\n\n- (NSString *)objectDescriptionAtIndex:(int)anInt\n{\n\tid object;\n\t\n\t[self getArgument:&object atIndex:anInt];\n\tif (object == nil)\n\t\treturn @\"nil\";\n\telse if(![object isProxy] && [object isKindOfClass:[NSString class]])\n\t\treturn [NSString stringWithFormat:@\"@\\\"%@\\\"\", [object description]];\n\telse\n\t\t// The description cannot be nil, if it is then replace it\n\t\treturn [object description] ?: @\"<nil description>\";\n}\n\n- (NSString *)boolDescriptionAtIndex:(int)anInt\n{\n\tbool value;\n\t[self getArgument:&value atIndex:anInt];\n\treturn value? @\"YES\" : @\"NO\";\n}\n\n- (NSString *)charDescriptionAtIndex:(int)anInt\n{\n\tunsigned char buffer[128];\n\tmemset(buffer, 0x0, 128);\n\t\n\t[self getArgument:&buffer atIndex:anInt];\n\t\n\t// If there's only one character in the buffer, and it's 0 or 1, then we have a BOOL\n\tif (buffer[1] == '\\0' && (buffer[0] == 0 || buffer[0] == 1))\n\t\treturn (buffer[0] == 1 ? @\"YES\" : @\"NO\");\n\telse\n\t\treturn [NSString stringWithFormat:@\"'%c'\", *buffer];\n}\n\n- (NSString *)unsignedCharDescriptionAtIndex:(int)anInt\n{\n\tunsigned char buffer[128];\n\tmemset(buffer, 0x0, 128);\n\t\n\t[self getArgument:&buffer atIndex:anInt];\n\treturn [NSString stringWithFormat:@\"'%c'\", *buffer];\n}\n\n- (NSString *)intDescriptionAtIndex:(int)anInt\n{\n\tint intValue;\n\t\n\t[self getArgument:&intValue atIndex:anInt];\n\treturn [NSString stringWithFormat:@\"%d\", intValue];\n}\n\n- (NSString *)unsignedIntDescriptionAtIndex:(int)anInt\n{\n\tunsigned int intValue;\n\t\n\t[self getArgument:&intValue atIndex:anInt];\n\treturn [NSString stringWithFormat:@\"%d\", intValue];\n}\n\n- (NSString *)shortDescriptionAtIndex:(int)anInt\n{\n\tshort shortValue;\n\t\n\t[self getArgument:&shortValue atIndex:anInt];\n\treturn [NSString stringWithFormat:@\"%hi\", shortValue];\n}\n\n- (NSString *)unsignedShortDescriptionAtIndex:(int)anInt\n{\n\tunsigned short shortValue;\n\t\n\t[self getArgument:&shortValue atIndex:anInt];\n\treturn [NSString stringWithFormat:@\"%hu\", shortValue];\n}\n\n- (NSString *)longDescriptionAtIndex:(int)anInt\n{\n\tlong longValue;\n\t\n\t[self getArgument:&longValue atIndex:anInt];\n\treturn [NSString stringWithFormat:@\"%ld\", longValue];\n}\n\n- (NSString *)unsignedLongDescriptionAtIndex:(int)anInt\n{\n\tunsigned long longValue;\n\t\n\t[self getArgument:&longValue atIndex:anInt];\n\treturn [NSString stringWithFormat:@\"%lu\", longValue];\n}\n\n- (NSString *)longLongDescriptionAtIndex:(int)anInt\n{\n\tlong long longLongValue;\n\t\n\t[self getArgument:&longLongValue atIndex:anInt];\n\treturn [NSString stringWithFormat:@\"%qi\", longLongValue];\n}\n\n- (NSString *)unsignedLongLongDescriptionAtIndex:(int)anInt\n{\n\tunsigned long long longLongValue;\n\t\n\t[self getArgument:&longLongValue atIndex:anInt];\n\treturn [NSString stringWithFormat:@\"%qu\", longLongValue];\n}\n\n- (NSString *)doubleDescriptionAtIndex:(int)anInt\n{\n\tdouble doubleValue;\n\t\n\t[self getArgument:&doubleValue atIndex:anInt];\n\treturn [NSString stringWithFormat:@\"%f\", doubleValue];\n}\n\n- (NSString *)floatDescriptionAtIndex:(int)anInt\n{\n\tfloat floatValue;\n\t\n\t[self getArgument:&floatValue atIndex:anInt];\n\treturn [NSString stringWithFormat:@\"%f\", floatValue];\n}\n\n- (NSString *)longDoubleDescriptionAtIndex:(int)anInt\n{\n\tlong double longDoubleValue;\n\t\n\t[self getArgument:&longDoubleValue atIndex:anInt];\n\treturn [NSString stringWithFormat:@\"%Lf\", longDoubleValue];\n}\n\n- (NSString *)structDescriptionAtIndex:(int)anInt\n{\n    return [NSString stringWithFormat:@\"(%@)\", [[self getArgumentAtIndexAsObject:anInt] description]];\n}\n\n- (NSString *)pointerDescriptionAtIndex:(int)anInt\n{\n\tvoid *buffer;\n\t\n\t[self getArgument:&buffer atIndex:anInt];\n\treturn [NSString stringWithFormat:@\"%p\", buffer];\n}\n\n- (NSString *)cStringDescriptionAtIndex:(int)anInt\n{\n\tchar buffer[104];\n\tchar *cStringPtr;\n\t\n\t[self getArgument:&cStringPtr atIndex:anInt];\n\tstrncpy(buffer, cStringPtr, 100);\n    strcpy(buffer + 100, \"...\");\n\treturn [NSString stringWithFormat:@\"\\\"%s\\\"\", buffer];\n}\n\n- (NSString *)selectorDescriptionAtIndex:(int)anInt\n{\n\tSEL selectorValue;\n\t\n\t[self getArgument:&selectorValue atIndex:anInt];\n\treturn [NSString stringWithFormat:@\"@selector(%@)\", NSStringFromSelector(selectorValue)];\n}\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,290,null,290,null,364,0,null,290,null,null,null,null,156,156,156,null,null,null,12,12,12,null,null,null,0,0,0,null,null,null,0,0,0,null,null,null,0,0,0,null,null,null,0,0,0,null,null,null,12,12,12,null,null,null,0,0,0,null,null,null,0,0,0,null,null,null,0,0,0,null,null,null,0,0,0,null,null,null,44,44,44,null,null,null,0,0,0,null,null,null,0,0,0,null,null,null,0,0,0,null,null,null,0,0,0,null,null,null,52,52,52,null,null,null,14,14,14,0,14,14,14,null,null,null,0,0,290,null,null,null,152,152,null,152,54,null,98,98,98,472,null,138,138,138,null,98,152,null,138,null,138,null,138,null,52,0,8,2,2,2,2,2,0,0,4,26,2,2,2,6,18,2,6,0,null,null,138,null,null,52,null,52,null,52,52,2,94,30,null,null,60,52,null,0,null,0,0,0,null,null,8,null,8,8,null,8,null,null,24,6,null,2,8,null,2,null,2,2,null,2,2,null,null,2,null,2,null,2,2,null,null,2,null,2,null,2,2,null,null,2,null,2,null,2,2,null,null,2,null,2,null,2,2,null,null,0,null,0,null,0,0,null,null,0,null,0,null,0,0,null,null,4,null,4,null,4,4,null,null,26,null,26,null,26,26,null,null,2,null,2,null,2,2,null,null,2,null,2,null,2,2,null,null,2,null,2,null,2,2,null,null,6,null,6,null,null,18,null,18,null,18,18,null,null,2,null,2,2,null,2,2,2,2,null,null,6,null,6,null,6,6,null,null,null]},{"name":"OCMock/NSMethodSignature+OCMAdditions.m","source":"/*\n *  Copyright (c) 2009-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import \"NSMethodSignature+OCMAdditions.h\"\n#import \"OCMFunctions.h\"\n#import <objc/runtime.h>\n\n\n@implementation NSMethodSignature(OCMAdditions)\n\n- (BOOL)usesSpecialStructureReturn\n{\n    const char *types = OCMTypeWithoutQualifiers([self methodReturnType]);\n\n    if((types == NULL) || (types[0] != '{'))\n        return NO;\n\n    /* In some cases structures are returned by ref. The rules are complex and depend on the\n       architecture, see:\n\n       http://sealiesoftware.com/blog/archive/2008/10/30/objc_explain_objc_msgSend_stret.html\n       http://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/LowLevelABI/000-Introduction/introduction.html\n       https://github.com/atgreen/libffi/blob/master/src/x86/ffi64.c\n       http://www.uclibc.org/docs/psABI-x86_64.pdf\n       http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf\n\n       NSMethodSignature knows the details but has no API to return it, though it is in\n       the debugDescription. Horribly kludgy.\n    */\n    NSRange range = [[self debugDescription] rangeOfString:@\"is special struct return? YES\"];\n    return range.length > 0;\n}\n\n- (NSString *)fullTypeString\n{\n    NSMutableString *typeString = [NSMutableString string];\n    [typeString appendFormat:@\"%s\", [self methodReturnType]];\n    for (NSUInteger i=0; i<[self numberOfArguments]; i++)\n        [typeString appendFormat:@\"%s\", [self getArgumentTypeAtIndex:i]];\n    return typeString;\n}\n\n- (const char *)fullObjCTypes\n{\n    return [[self fullTypeString] UTF8String];\n}\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,47942,null,95884,47890,null,null,null,null,null,null,null,null,null,null,null,null,null,52,52,47942,null,null,null,0,0,0,0,0,null,null,null,null,0,null,null,null]},{"name":"OCMock/NSNotificationCenter+OCMAdditions.m","source":"/*\n *  Copyright (c) 2009-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import \"NSNotificationCenter+OCMAdditions.h\"\n#import \"OCObserverMockObject.h\"\n\n\n@implementation NSNotificationCenter(OCMAdditions)\n\n- (void)addMockObserver:(OCObserverMockObject *)notificationObserver name:(NSString *)notificationName object:(id)notificationSender\n{\n    [notificationObserver autoRemoveFromCenter:self];\n\t[self addObserver:notificationObserver selector:@selector(handleNotification:) name:notificationName object:notificationSender];\n}\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,26,null,26,26,26,null,null]},{"name":"OCMock/NSObject+OCMAdditions.m","source":"/*\n *  Copyright (c) 2009-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import \"NSObject+OCMAdditions.h\"\n#import \"NSMethodSignature+OCMAdditions.h\"\n#import <objc/runtime.h>\n\n@implementation NSObject(OCMAdditions)\n\n+ (IMP)instanceMethodForwarderForSelector:(SEL)aSelector\n{\n    // use NSSelectorFromString and not @selector to avoid warning\n    SEL selectorWithNoImplementation = NSSelectorFromString(@\"methodWhichMustNotExist::::\");\n\n#ifndef __arm64__\n    NSMethodSignature *sig = [self instanceMethodSignatureForSelector:aSelector];\n    if([sig usesSpecialStructureReturn])\n        return class_getMethodImplementation_stret(self, selectorWithNoImplementation);\n#endif\n    \n    return class_getMethodImplementation(self, selectorWithNoImplementation);\n}\n\n\n+ (void)enumerateMethodsInClass:(Class)aClass usingBlock:(void (^)(SEL selector))aBlock\n{\n    for(Class cls = aClass; cls != nil; cls = class_getSuperclass(cls))\n    {\n        Method *methodList = class_copyMethodList(cls, NULL);\n        if(methodList == NULL)\n            continue;\n        for(Method *mPtr = methodList; *mPtr != NULL; mPtr++)\n        {\n            SEL selector = method_getName(*mPtr);\n            aBlock(selector);\n        }\n        free(methodList);\n    }\n}\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,47916,null,null,47916,null,null,47916,47916,32,null,null,47884,47916,null,null,162,null,1244,null,460,460,60,99480,null,49340,49340,49340,400,400,162,null,null]},{"name":"OCMock/OCClassMockObject.m","source":"/*\n *  Copyright (c) 2005-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import <objc/runtime.h>\n#import \"OCClassMockObject.h\"\n#import \"NSObject+OCMAdditions.h\"\n#import \"OCMFunctions.h\"\n#import \"OCMMacroState.h\"\n\n\n@implementation OCClassMockObject\n\n#pragma mark  Initialisers, description, accessors, etc.\n\n- (id)initWithClass:(Class)aClass\n{\n\t[super init];\n\tmockedClass = aClass;\n    [self prepareClassForClassMethodMocking];\n\treturn self;\n}\n\n- (void)dealloc\n{\n\t[self stopMocking];\n\t[super dealloc];\n}\n\n- (NSString *)description\n{\n\treturn [NSString stringWithFormat:@\"OCMockObject[%@]\", NSStringFromClass(mockedClass)];\n}\n\n- (Class)mockedClass\n{\n\treturn mockedClass;\n}\n\n#pragma mark  Extending/overriding superclass behaviour\n\n- (void)stopMocking\n{\n    if(originalMetaClass != nil)\n        [self restoreMetaClass];\n    [super stopMocking];\n}\n\n- (void)restoreMetaClass\n{\n    OCMSetAssociatedMockForClass(nil, mockedClass);\n    OCMSetIsa(mockedClass, originalMetaClass);\n    originalMetaClass = nil;\n}\n\n\n#pragma mark  Class method mocking\n\n- (void)prepareClassForClassMethodMocking\n{\n    /* haven't figured out how to work around runtime dependencies on NSString, so exclude it for now */\n    /* also weird: [[NSString class] isKindOfClass:[NSString class]] is false, hence the additional clause */\n    if([[mockedClass class] isKindOfClass:[NSString class]] || (mockedClass == [NSString class]))\n        return;\n\n    /* if there is another mock for this exact class, stop it */\n    id otherMock = OCMGetAssociatedMockForClass(mockedClass, NO);\n    if(otherMock != nil)\n        [otherMock restoreMetaClass];\n\n    OCMSetAssociatedMockForClass(self, mockedClass);\n\n    /* dynamically create a subclass and use its meta class as the meta class for the mocked class */\n    Class subclass = OCMCreateSubclass(mockedClass, mockedClass);\n    originalMetaClass = object_getClass(mockedClass);\n    id newMetaClass = object_getClass(subclass);\n    OCMSetIsa(mockedClass, OCMGetIsa(subclass));\n\n    /* point forwardInvocation: of the object to the implementation in the mock */\n    Method myForwardMethod = class_getInstanceMethod([self mockObjectClass], @selector(forwardInvocationForClassObject:));\n    IMP myForwardIMP = method_getImplementation(myForwardMethod);\n    class_addMethod(newMetaClass, @selector(forwardInvocation:), myForwardIMP, method_getTypeEncoding(myForwardMethod));\n\n    /* adding forwarder for all class methods (instance methods on meta class) to allow for verify after run */\n    NSArray *whiteList = @[@\"class\", @\"forwardingTargetForSelector:\", @\"methodSignatureForSelector:\", @\"forwardInvocation:\"];\n    [NSObject enumerateMethodsInClass:originalMetaClass usingBlock:^(SEL selector) {\n            if(![whiteList containsObject:NSStringFromSelector(selector)])\n                [self setupForwarderForClassMethodSelector:selector];\n    }];\n}\n\n- (void)setupForwarderForClassMethodSelector:(SEL)selector\n{\n    Method originalMethod = class_getClassMethod(mockedClass, selector);\n    IMP originalIMP = method_getImplementation(originalMethod);\n    const char *types = method_getTypeEncoding(originalMethod);\n\n    Class metaClass = object_getClass(mockedClass);\n    IMP forwarderIMP = [metaClass instanceMethodForwarderForSelector:selector];\n    class_replaceMethod(metaClass, selector, forwarderIMP, types);\n    SEL aliasSelector = OCMAliasForOriginalSelector(selector);\n    class_addMethod(metaClass, aliasSelector, originalIMP, types);\n}\n\n\n- (void)forwardInvocationForClassObject:(NSInvocation *)anInvocation\n{\n\t// in here \"self\" is a reference to the real class, not the mock\n\tOCClassMockObject *mock = OCMGetAssociatedMockForClass((Class) self, YES);\n    if(mock == nil)\n    {\n        [NSException raise:NSInternalInconsistencyException format:@\"No mock for class %@\", NSStringFromClass((Class)self)];\n    }\n\tif([mock handleInvocation:anInvocation] == NO)\n    {\n        [anInvocation setSelector:OCMAliasForOriginalSelector([anInvocation selector])];\n        [anInvocation invoke];\n    }\n}\n\n\n#pragma mark  Proxy API\n\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n{\n    OCMMacroState *macroState = [OCMMacroState globalState];\n    if(macroState != nil)\n    {\n        if([macroState hasSwitchedToClassMethod])\n        {\n            return [mockedClass methodSignatureForSelector:aSelector];\n        }\n        else\n        {\n            NSMethodSignature *signature = [mockedClass instanceMethodSignatureForSelector:aSelector];\n            if((signature == nil) && [mockedClass respondsToSelector:aSelector])\n            {\n                [macroState switchToClassMethod];\n                signature = [mockedClass methodSignatureForSelector:aSelector];\n            }\n            return signature;\n        }\n    }\n    else\n    {\n        return [mockedClass instanceMethodSignatureForSelector:aSelector];\n    }\n}\n\n- (Class)mockObjectClass\n{\n    return [super class];\n}\n\n- (Class)class\n{\n    return mockedClass;\n}\n\n- (BOOL)respondsToSelector:(SEL)selector\n{\n    return [mockedClass instancesRespondToSelector:selector];\n}\n\n- (BOOL)isKindOfClass:(Class)aClass\n{\n    return [mockedClass isSubclassOfClass:aClass];\n}\n\n- (BOOL)conformsToProtocol:(Protocol *)aProtocol\n{\n    return class_conformsToProtocol(mockedClass, aProtocol);\n}\n\n@end\n\n\n#pragma mark  -\n\n/**\n taken from:\n `class-dump -f isNS /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator7.0.sdk/System/Library/Frameworks/CoreFoundation.framework`\n \n @interface NSObject (__NSIsKinds)\n - (_Bool)isNSValue__;\n - (_Bool)isNSTimeZone__;\n - (_Bool)isNSString__;\n - (_Bool)isNSSet__;\n - (_Bool)isNSOrderedSet__;\n - (_Bool)isNSNumber__;\n - (_Bool)isNSDictionary__;\n - (_Bool)isNSDate__;\n - (_Bool)isNSData__;\n - (_Bool)isNSArray__;\n */\n\n@implementation OCClassMockObject(NSIsKindsImplementation)\n\n- (BOOL)isNSValue__\n{\n    return [mockedClass isKindOfClass:[NSValue class]];\n}\n\n- (BOOL)isNSTimeZone__\n{\n    return [mockedClass isKindOfClass:[NSTimeZone class]];\n}\n\n- (BOOL)isNSSet__\n{\n    return [mockedClass isKindOfClass:[NSSet class]];\n}\n\n- (BOOL)isNSOrderedSet__\n{\n    return [mockedClass isKindOfClass:[NSOrderedSet class]];\n}\n\n- (BOOL)isNSNumber__\n{\n    return [mockedClass isKindOfClass:[NSNumber class]];\n}\n\n- (BOOL)isNSDate__\n{\n    return [mockedClass isKindOfClass:[NSDate class]];\n}\n\n- (BOOL)isNSString__\n{\n    return [mockedClass isKindOfClass:[NSString class]];\n}\n\n- (BOOL)isNSDictionary__\n{\n    return [mockedClass isKindOfClass:[NSDictionary class]];\n}\n\n- (BOOL)isNSData__\n{\n    return [mockedClass isKindOfClass:[NSData class]];\n}\n\n- (BOOL)isNSArray__\n{\n    return [mockedClass isKindOfClass:[NSArray class]];\n}\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,322,null,322,322,322,322,null,null,null,null,312,312,312,null,null,null,92,null,null,null,null,208,null,null,null,null,null,null,378,116,378,378,null,null,null,120,120,120,120,null,null,null,null,null,null,null,null,644,200,null,null,122,122,4,null,122,null,null,122,122,122,122,null,null,122,122,122,null,null,40246,40246,40124,38904,40124,444,null,38904,null,38904,38904,38904,null,38904,38904,38904,38904,38904,38904,null,null,18952,null,null,18952,18952,null,0,0,18952,null,18908,18908,18908,18952,null,null,null,null,462,null,462,462,null,34,null,4,null,null,null,30,36,null,4,4,4,30,null,null,null,null,428,null,462,null,null,null,248,null,null,null,null,218,null,null,20,null,20,null,null,2,null,2,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,12,null,null,null,null,8,null,null,null,null,8,null,null,null,null,8,null,null,null]},{"name":"OCMock/OCMArg.m","source":"/*\n *  Copyright (c) 2009-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import <objc/runtime.h>\n#import <OCMock/OCMArg.h>\n#import <OCMock/OCMConstraint.h>\n#import \"OCMPassByRefSetter.h\"\n\n@implementation OCMArg\n\n+ (id)any\n{\n\treturn [OCMAnyConstraint constraint];\n}\n\n+ (void *)anyPointer\n{\n\treturn (void *)0x01234567;\n}\n\n+ (id __autoreleasing *)anyObjectRef\n{\n    return (id *)0x01234567;\n}\n\n+ (SEL)anySelector\n{\n    return NSSelectorFromString(@\"aSelectorThatMatchesAnySelector\");\n}\n\n+ (id)isNil\n{\n\treturn [OCMIsNilConstraint constraint];\n}\n\n+ (id)isNotNil\n{\n\treturn [OCMIsNotNilConstraint constraint];\n}\n\n+ (id)isNotEqual:(id)value\n{\n\tOCMIsNotEqualConstraint *constraint = [OCMIsNotEqualConstraint constraint];\n\tconstraint->testValue = value;\n\treturn constraint;\n}\n\n+ (id)checkWithSelector:(SEL)selector onObject:(id)anObject\n{\n\treturn [OCMConstraint constraintWithSelector:selector onObject:anObject];\n}\n\n+ (id)checkWithBlock:(BOOL (^)(id))block\n{\n\treturn [[[OCMBlockConstraint alloc] initWithConstraintBlock:block] autorelease];\n}\n\n+ (id *)setTo:(id)value\n{\n\treturn (id *)[[[OCMPassByRefSetter alloc] initWithValue:value] autorelease];\n}\n\n+ (void *)setToValue:(NSValue *)value\n{\n\treturn (id *)[[[OCMPassByRefSetter alloc] initWithValue:value] autorelease];\n}\n\n+ (id)resolveSpecialValues:(NSValue *)value\n{\n\tconst char *type = [value objCType];\n\tif(type[0] == '^')\n\t{\n\t\tvoid *pointer = [value pointerValue];\n\t\tif(pointer == (void *)0x01234567)\n\t\t\treturn [OCMArg any];\n\t\tif((pointer != NULL) && (object_getClass((id)pointer) == [OCMPassByRefSetter class]))\n\t\t\treturn (id)pointer;\n\t}\n    else if(type[0] == ':')\n    {\n        SEL selector;\n        [value getValue:&selector];\n        if(selector == NSSelectorFromString(@\"aSelectorThatMatchesAnySelector\"))\n            return [OCMArg any];\n    }\n\treturn value;\n}\n\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,48,null,null,null,null,2,null,null,null,null,2,null,null,null,null,2,null,null,null,null,0,null,null,null,null,0,null,null,0,null,0,0,0,null,null,0,null,0,null,null,2,null,2,null,null,4,null,4,null,null,2,null,2,null,null,64,null,64,64,null,26,26,4,40,6,16,38,null,6,6,6,2,4,52,64,null,null,null]},{"name":"OCMock/OCMBlockCaller.m","source":"/*\n *  Copyright (c) 2010-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import \"OCMBlockCaller.h\"\n\n\n@implementation OCMBlockCaller\n\n-(id)initWithCallBlock:(void (^)(NSInvocation *))theBlock \n{\n\tself = [super init];\n\tblock = [theBlock copy];\n\treturn self;\n}\n\n-(void)dealloc \n{\n\t[block release];\n\t[super dealloc];\n}\n\n- (void)handleInvocation:(NSInvocation *)anInvocation\n{\n    if (block != nil)\n    {\n        block(anInvocation);\n    }\n}\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,6,null,6,6,6,null,null,null,null,6,6,6,null,10,null,10,null,6,6,10,null,null]},{"name":"OCMock/OCMBoxedReturnValueProvider.m","source":"/*\n *  Copyright (c) 2009-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import \"OCMBoxedReturnValueProvider.h\"\n#import <objc/runtime.h>\n\n@implementation OCMBoxedReturnValueProvider\n\n- (void)handleInvocation:(NSInvocation *)anInvocation\n{\n\tconst char *returnType = [[anInvocation methodSignature] methodReturnType];\n\tconst char *valueType = [(NSValue *)returnValue objCType];\n\t/* ARM64 uses 'B' for BOOLs in method signatures but 'c' in NSValue; that case should match */\n\tif((strcmp(returnType, valueType) != 0) && !(returnType[0] == 'B' && valueType[0] == 'c'))\n\t\t@throw [NSException exceptionWithName:NSInvalidArgumentException reason:[NSString stringWithFormat:@\"Return value does not match method signature; signature declares '%s' but value is '%s'.\", returnType, valueType] userInfo:nil];\n\tvoid *buffer = malloc([[anInvocation methodSignature] methodReturnLength]);\n\t[returnValue getValue:buffer];\n\t[anInvocation setReturnValue:buffer];\n\tfree(buffer);\n}\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,14,null,14,14,null,16,2,12,12,12,12,12,null,null]},{"name":"OCMock/OCMConstraint.m","source":"/*\n *  Copyright (c) 2007-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import <OCMock/OCMConstraint.h>\n\n\n@implementation OCMConstraint\n\n+ (id)constraint\n{\n\treturn [[[self alloc] init] autorelease];\n}\n\n- (BOOL)evaluate:(id)value\n{\n\treturn NO;\n}\n\n- (id)copyWithZone:(struct _NSZone *)zone\n{\n    return [self retain];\n}\n\n+ (id)constraintWithSelector:(SEL)aSelector onObject:(id)anObject\n{\n\tOCMInvocationConstraint *constraint = [OCMInvocationConstraint constraint];\n\tNSMethodSignature *signature = [anObject methodSignatureForSelector:aSelector]; \n\tif(signature == nil)\n\t\t[NSException raise:NSInvalidArgumentException format:@\"Unkown selector %@ used in constraint.\", NSStringFromSelector(aSelector)];\n\tNSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];\n\t[invocation setTarget:anObject];\n\t[invocation setSelector:aSelector];\n\tconstraint->invocation = invocation;\n\treturn constraint;\n}\n\n+ (id)constraintWithSelector:(SEL)aSelector onObject:(id)anObject withValue:(id)aValue\n{\n\tOCMInvocationConstraint *constraint = [self constraintWithSelector:aSelector onObject:anObject];\n\tif([[constraint->invocation methodSignature] numberOfArguments] < 4)\n\t\t[NSException raise:NSInvalidArgumentException format:@\"Constraint with value requires selector with two arguments.\"];\n\t[constraint->invocation setArgument:&aValue atIndex:3];\n\treturn constraint;\n}\n\n\n@end\n\n\n\n#pragma mark  -\n\n@implementation OCMAnyConstraint\n\n- (BOOL)evaluate:(id)value\n{\n\treturn YES;\n}\n\n@end\n\n\n\n#pragma mark  -\n\n@implementation OCMIsNilConstraint\n\n- (BOOL)evaluate:(id)value\n{\n\treturn value == nil;\n}\n\n@end\n\n\n\n#pragma mark  -\n\n@implementation OCMIsNotNilConstraint\n\n- (BOOL)evaluate:(id)value\n{\n\treturn value != nil;\n}\n\n@end\n\n\n\n#pragma mark  -\n\n@implementation OCMIsNotEqualConstraint\n\n- (BOOL)evaluate:(id)value\n{\n\treturn ![value isEqual:testValue];\n}\n\n@end\n\n\n\n#pragma mark  -\n\n@implementation OCMInvocationConstraint\n\n- (BOOL)evaluate:(id)value\n{\n\t[invocation setArgument:&value atIndex:2]; // should test if constraint takes arg\n\t[invocation invoke];\n\tBOOL returnValue;\n\t[invocation getReturnValue:&returnValue];\n\treturn returnValue;\n}\n\n@end\n\n#pragma mark  -\n\n@implementation OCMBlockConstraint\n\n- (id)initWithConstraintBlock:(BOOL (^)(id))aBlock\n{\n\tself = [super init];\n\tblock = [aBlock copy];\n\treturn self;\n}\n\n- (void)dealloc {\n    [block release];\n    [super dealloc];\n}\n\n- (BOOL)evaluate:(id)value \n{\n\treturn block(value);\n}\n\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,64,null,null,0,null,0,null,null,2,null,2,null,null,8,null,8,8,8,2,6,6,6,6,6,null,null,4,null,4,4,2,2,2,null,null,null,null,null,null,null,null,null,null,null,52,null,52,null,null,null,null,null,null,null,null,null,null,4,null,4,null,null,null,null,null,null,null,null,null,null,4,null,4,null,null,null,null,null,null,null,null,null,null,6,null,6,null,null,null,null,null,null,null,null,null,null,8,null,8,8,8,8,8,null,null,null,null,null,null,null,null,6,null,6,6,6,null,null,null,0,0,0,null,12,null,12,null,null,null,null]},{"name":"OCMock/OCMExceptionReturnValueProvider.m","source":"/*\n *  Copyright (c) 2009-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import \"OCMExceptionReturnValueProvider.h\"\n\n\n@implementation OCMExceptionReturnValueProvider\n\n- (void)handleInvocation:(NSInvocation *)anInvocation\n{\n\t@throw returnValue;\n}\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,null,4,0,null,null]},{"name":"OCMock/OCMFunctions.m","source":"/*\n *  Copyright (c) 2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import <objc/runtime.h>\n#import \"OCMFunctions.h\"\n#import \"OCMLocation.h\"\n#import \"OCClassMockObject.h\"\n#import \"OCPartialMockObject.h\"\n\n\n#pragma mark  Known private API\n\n@interface NSException(OCMKnownExceptionMethods)\n+ (NSException *)failureInFile:(NSString *)file atLine:(int)line withDescription:(NSString *)formatString, ...;\n@end\n\n@interface NSObject(OCMKnownTestCaseMethods)\n- (void)recordFailureWithDescription:(NSString *)description inFile:(NSString *)file atLine:(NSUInteger)line expected:(BOOL)expected;\n- (void)failWithException:(NSException *)exception;\n@end\n\n\n#pragma mark  Functions related to ObjC type system\n\nBOOL OCMIsObjectType(const char *objCType)\n{\n    objCType = OCMTypeWithoutQualifiers(objCType);\n\n    if(strcmp(objCType, @encode(id)) == 0)\n        return YES;\n\n    // if the returnType is a typedef to an object, it has the form ^{OriginClass=#}\n    NSString *regexString = @\"^\\\\^\\\\{(.*)=#.*\\\\}\";\n    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:regexString options:0 error:NULL];\n    NSString *type = [NSString stringWithCString:objCType encoding:NSASCIIStringEncoding];\n    if([regex numberOfMatchesInString:type options:0 range:NSMakeRange(0, type.length)] > 0)\n        return YES;\n\n    return NO;\n}\n\n\nconst char *OCMTypeWithoutQualifiers(const char *objCType)\n{\n    while(strchr(\"rnNoORV\", objCType[0]) != NULL)\n        objCType += 1;\n    return objCType;\n}\n\n\n#pragma mark  Creating classes\n\nClass OCMCreateSubclass(Class class, void *ref)\n{\n    double timestamp = [NSDate timeIntervalSinceReferenceDate];\n    const char *className = [[NSString stringWithFormat:@\"%@-%p-%f\", NSStringFromClass(class), ref, timestamp] UTF8String];\n    Class subclass = objc_allocateClassPair(class, className, 0);\n    objc_registerClassPair(subclass);\n    return subclass;\n}\n\n#pragma mark  Directly manipulating the isa pointer (look away)\n\nvoid OCMSetIsa(id object, Class class)\n{\n    *((Class *)object) = class;\n}\n\nClass OCMGetIsa(id object)\n{\n    return *((Class *)object);\n}\n\n\n#pragma mark  Alias for renaming real methods\n\nNSString *OCMRealMethodAliasPrefix = @\"ocmock_replaced_\";\n\n\nBOOL OCMIsAliasSelector(SEL selector)\n{\n    return [NSStringFromSelector(selector) hasPrefix:OCMRealMethodAliasPrefix];\n}\n\nSEL OCMAliasForOriginalSelector(SEL selector)\n{\n    NSString *string = NSStringFromSelector(selector);\n    return NSSelectorFromString([OCMRealMethodAliasPrefix stringByAppendingString:string]);\n\n}\n\nSEL OCMOriginalSelectorForAlias(SEL selector)\n{\n    if(!OCMIsAliasSelector(selector))\n        [NSException raise:NSInvalidArgumentException format:@\"Not an alias selector; found %@\", NSStringFromSelector(selector)];\n    NSString *string = NSStringFromSelector(selector);\n    return NSSelectorFromString([string substringFromIndex:[OCMRealMethodAliasPrefix length]]);\n}\n\n#pragma mark  Wrappers around associative references\n\nNSString *OCMClassMethodMockObjectKey = @\"OCMClassMethodMockObjectKey\";\n\nvoid OCMSetAssociatedMockForClass(OCClassMockObject *mock, Class aClass)\n{\n    if((mock != nil) && (objc_getAssociatedObject(aClass, OCMClassMethodMockObjectKey) != nil))\n        [NSException raise:NSInternalInconsistencyException format:@\"Another mock is already associated with class %@\", NSStringFromClass(aClass)];\n    objc_setAssociatedObject(aClass, OCMClassMethodMockObjectKey, mock, OBJC_ASSOCIATION_ASSIGN);\n}\n\nOCClassMockObject *OCMGetAssociatedMockForClass(Class aClass, BOOL includeSuperclasses)\n{\n    OCClassMockObject *mock = nil;\n    do\n    {\n        mock = objc_getAssociatedObject(aClass, OCMClassMethodMockObjectKey);\n        aClass = class_getSuperclass(aClass);\n    }\n    while((mock == nil) && (aClass != nil) && includeSuperclasses);\n    return mock;\n}\n\nNSString *OCMPartialMockObjectKey = @\"OCMPartialMockObjectKey\";\n\nvoid OCMSetAssociatedMockForObject(OCClassMockObject *mock, id anObject)\n{\n    if((mock != nil) && (objc_getAssociatedObject(anObject, OCMPartialMockObjectKey) != nil))\n        [NSException raise:NSInternalInconsistencyException format:@\"Another mock is already associated with object %@\", anObject];\n    objc_setAssociatedObject(anObject, OCMPartialMockObjectKey, mock, OBJC_ASSOCIATION_ASSIGN);\n}\n\nOCPartialMockObject *OCMGetAssociatedMockForObject(id anObject)\n{\n    return objc_getAssociatedObject(anObject, OCMPartialMockObjectKey);\n}\n\n\n#pragma mark  Functions related to IDE error reporting\n\nvoid OCMReportFailure(OCMLocation *loc, NSString *description)\n{\n    id testCase = [loc testCase];\n    if((testCase != nil) && [testCase respondsToSelector:@selector(recordFailureWithDescription:inFile:atLine:expected:)])\n    {\n        [testCase recordFailureWithDescription:description inFile:[loc file] atLine:[loc line] expected:NO];\n    }\n    else if((testCase != nil) && [testCase respondsToSelector:@selector(failWithException:)])\n    {\n        NSException *exception = nil;\n        if([NSException instancesRespondToSelector:@selector(failureInFile:atLine:withDescription:)])\n        {\n            exception = [NSException failureInFile:[loc file] atLine:(int)[loc line] withDescription:description];\n        }\n        else\n        {\n            NSString *reason = [NSString stringWithFormat:@\"%@:%lu %@\", [loc file], (unsigned long)[loc line], description];\n            exception = [NSException exceptionWithName:@\"OCMockTestFailure\" reason:reason userInfo:nil];\n        }\n        [testCase failWithException:exception];\n    }\n    else if(loc != nil)\n    {\n        NSLog(@\"%@:%lu %@\", [loc file], (unsigned long)[loc line], description);\n        NSString *reason = [NSString stringWithFormat:@\"%@:%lu %@\", [loc file], (unsigned long)[loc line], description];\n        [[NSException exceptionWithName:@\"OCMockTestFailure\" reason:reason userInfo:nil] raise];\n\n    }\n    else\n    {\n        NSLog(@\"%@\", description);\n        [[NSException exceptionWithName:@\"OCMockTestFailure\" reason:description userInfo:nil] raise];\n    }\n\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,102,null,102,null,102,94,null,null,8,8,8,8,2,null,6,102,null,null,48472,null,97702,758,48472,null,null,null,null,null,162,null,162,162,162,162,162,null,null,null,null,242,null,242,242,null,122,null,122,null,null,null,null,null,null,null,null,118,null,118,null,null,66930,null,66930,66930,null,null,null,32,null,32,0,32,32,null,null,null,null,null,null,242,null,364,0,242,242,null,19074,null,19074,19074,null,37712,37712,112930,null,19074,null,null,null,null,82,null,124,2,80,80,null,312,null,312,null,null,null,null,null,34,null,34,42,null,8,8,26,null,0,0,null,0,0,null,null,0,0,null,0,0,26,null,0,0,0,null,0,null,null,26,26,null,null,8]},{"name":"OCMock/OCMIndirectReturnValueProvider.m","source":"/*\n *  Copyright (c) 2009-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import \"NSMethodSignature+OCMAdditions.h\"\n#import \"OCMIndirectReturnValueProvider.h\"\n\n\n@implementation OCMIndirectReturnValueProvider\n\n- (id)initWithProvider:(id)aProvider andSelector:(SEL)aSelector\n{\n\tself = [super init];\n\tprovider = [aProvider retain];\n\tselector = aSelector;\n\treturn self;\n}\n\n- (void)dealloc\n{\n\t[provider release];\n\t[super dealloc];\n}\n\n- (void)handleInvocation:(NSInvocation *)anInvocation\n{\n\t[anInvocation setTarget:provider];\n\t[anInvocation setSelector:selector];\n\t[anInvocation invoke];\n}\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,8,null,8,8,8,8,null,null,null,null,8,8,8,null,8,null,8,8,8,8,null,null]},{"name":"OCMock/OCMInvocationMatcher.m","source":"/*\n *  Copyright (c) 2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import <objc/runtime.h>\n#import <OCMock/OCMArg.h>\n#import <OCMock/OCMConstraint.h>\n#import \"OCMPassByRefSetter.h\"\n#import \"NSInvocation+OCMAdditions.h\"\n#import \"OCMInvocationMatcher.h\"\n#import \"OCClassMockObject.h\"\n#import \"OCMFunctions.h\"\n\n\n@interface NSObject(HCMatcherDummy)\n- (BOOL)matches:(id)item;\n@end\n\n\n@implementation OCMInvocationMatcher\n\n- (void)setInvocation:(NSInvocation *)anInvocation;\n{\n    [recordedInvocation release];\n    [anInvocation retainArguments];\n    recordedInvocation = [anInvocation retain];\n}\n\n- (void)setRecordedAsClassMethod:(BOOL)flag\n{\n    recordedAsClassMethod = flag;\n}\n\n- (BOOL)recordedAsClassMethod\n{\n    return recordedAsClassMethod;\n}\n\n- (void)setIgnoreNonObjectArgs:(BOOL)flag\n{\n    ignoreNonObjectArgs = flag;\n}\n\n- (NSString *)description\n{\n    return [recordedInvocation invocationDescription];\n}\n\n- (BOOL)matchesSelector:(SEL)sel\n{\n    if(sel == [recordedInvocation selector])\n        return YES;\n    if(OCMIsAliasSelector(sel) &&\n       OCMOriginalSelectorForAlias(sel) == [recordedInvocation selector])\n        return YES;\n    return NO;\n}\n\n- (BOOL)matchesInvocation:(NSInvocation *)anInvocation\n{\n    id target = [anInvocation target];\n    BOOL isClassMethodInvocation = (target != nil) && (target == [target class]);\n    if(isClassMethodInvocation != recordedAsClassMethod)\n        return NO;\n\n    if(![self matchesSelector:[anInvocation selector]])\n        return NO;\n\n    NSMethodSignature *signature = [recordedInvocation methodSignature];\n    int n = (int)[signature numberOfArguments];\n    for(int i = 2; i < n; i++)\n    {\n        if(ignoreNonObjectArgs && strcmp([signature getArgumentTypeAtIndex:i], @encode(id)))\n        {\n            continue;\n        }\n\n        id recordedArg = [recordedInvocation getArgumentAtIndexAsObject:i];\n        id passedArg = [anInvocation getArgumentAtIndexAsObject:i];\n\n        if([recordedArg isProxy])\n        {\n            if(![recordedArg isEqual:passedArg])\n                return NO;\n            continue;\n        }\n\n        if([recordedArg isKindOfClass:[NSValue class]])\n            recordedArg = [OCMArg resolveSpecialValues:recordedArg];\n\n        if([recordedArg isKindOfClass:[OCMConstraint class]])\n        {\n            if([recordedArg evaluate:passedArg] == NO)\n                return NO;\n        }\n        else if([recordedArg isKindOfClass:[OCMPassByRefSetter class]])\n        {\n            id valueToSet = [(OCMPassByRefSetter *)recordedArg value];\n            // side effect but easier to do here than in handleInvocation\n            if(![valueToSet isKindOfClass:[NSValue class]])\n                *(id *)[passedArg pointerValue] = valueToSet;\n            else\n                [(NSValue *)valueToSet getValue:[passedArg pointerValue]];\n        }\n        else if([recordedArg conformsToProtocol:objc_getProtocol(\"HCMatcher\")])\n        {\n            if([recordedArg matches:passedArg] == NO)\n                return NO;\n        }\n        else\n        {\n            if(([recordedArg class] == [NSNumber class]) &&\n                    ([(NSNumber*)recordedArg compare:(NSNumber*)passedArg] != NSOrderedSame))\n                return NO;\n            if(([recordedArg isEqual:passedArg] == NO) &&\n                    !((recordedArg == nil) && (passedArg == nil)))\n                return NO;\n        }\n    }\n    return YES;\n}\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,308,null,308,308,308,308,null,80,null,80,80,null,null,null,540,null,null,8,null,8,8,null,null,null,62,null,null,378,null,378,292,86,32,10,76,378,null,2314,null,2314,4620,2314,1960,null,354,72,null,282,282,796,null,162,null,6,null,null,142,142,null,142,null,6,4,2,null,null,136,64,null,136,null,36,2,34,100,null,6,null,6,4,null,2,6,94,null,4,2,2,null,null,90,null,0,118,null,24,null,108,250,2314,null]},{"name":"OCMock/OCMLocation.m","source":"/*\n *  Copyright (c) 2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import \"OCMLocation.h\"\n\n@implementation OCMLocation\n\n+ (id)locationWithTestCase:(id)aTestCase file:(NSString *)aFile line:(NSUInteger)aLine\n{\n    return [[[OCMLocation alloc] initWithTestCase:aTestCase file:aFile line:aLine] autorelease];\n}\n\n- (id)initWithTestCase:(id)aTestCase file:(NSString *)aFile line:(NSUInteger)aLine\n{\n    self = [super init];\n    testCase = aTestCase;\n    file = [aFile retain];\n    line = aLine;\n    return self;\n}\n\n- (void)dealloc\n{\n    [file release];\n    [super dealloc];\n}\n\n- (id)testCase\n{\n    return testCase;\n}\n\n- (NSString *)file\n{\n    return file;\n}\n\n- (NSUInteger)line\n{\n    return line;\n}\n\n@end\n\n\nOCMLocation *OCMMakeLocation(id testCase, const char *fileCString, int line)\n{\n    return [OCMLocation locationWithTestCase:testCase file:[NSString stringWithUTF8String:fileCString] line:line];\n}\n\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,20,null,20,null,null,20,null,20,20,20,20,20,null,null,null,null,20,20,20,null,null,null,8,null,null,null,null,8,null,null,null,null,8,null,null,null,null,null,20,null,20,null,null]},{"name":"OCMock/OCMMacroState.m","source":"/*\n *  Copyright (c) 2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import \"OCMMacroState.h\"\n#import \"OCMockRecorder.h\"\n#import \"OCMVerifyMacroState.h\"\n#import \"OCMStubMacroState.h\"\n\n\n@implementation OCMMacroState\n\nOCMMacroState *globalState;\n\n\n+ (void)beginStubMacro\n{\n    globalState = [[[OCMStubMacroState alloc] init] autorelease];\n}\n\n+ (OCMockRecorder *)endStubMacro\n{\n    OCMockRecorder *recorder = [((OCMStubMacroState *)globalState) recorder];\n    globalState = nil;\n    return recorder;\n}\n\n\n+ (void)beginExpectMacro\n{\n    [self beginStubMacro];\n    [(OCMStubMacroState *)globalState setShouldRecordExpectation:YES];\n}\n\n+ (OCMockRecorder *)endExpectMacro\n{\n    return [self endStubMacro];\n}\n\n\n+ (void)beginVerifyMacroAtLocation:(OCMLocation *)aLocation\n{\n    globalState = [[[OCMVerifyMacroState alloc] initWithLocation:aLocation] autorelease];\n}\n\n+ (void)endVerifyMacro\n{\n    globalState = nil;\n}\n\n\n+ (OCMMacroState *)globalState\n{\n    return globalState;\n}\n\n\n- (void)dealloc\n{\n    if(globalState == self)\n        globalState = nil;\n    [super dealloc];\n}\n\n- (void)switchToClassMethod\n{\n\n}\n\n- (BOOL)hasSwitchedToClassMethod\n{\n    return NO;\n}\n\n- (void)handleInvocation:(NSInvocation *)anInvocation\n{\n    // to be implemented by subclasses\n}\n\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,28,28,null,null,null,28,28,28,null,null,null,null,null,4,4,4,null,null,null,4,null,null,null,12,null,12,12,null,null,null,10,10,null,null,null,null,738,null,null,null,null,null,40,2,40,40,null,null,null,null,0,null,null,null,0,null,null,0,null,null,0,null,null,null]},{"name":"OCMock/OCMNotificationPoster.m","source":"/*\n *  Copyright (c) 2009-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import \"OCMNotificationPoster.h\"\n\n\n@implementation OCMNotificationPoster\n\n- (id)initWithNotification:(id)aNotification\n{\n\tself = [super init];\n\tnotification = [aNotification retain];\n\treturn self;\n}\n\n- (void)dealloc\n{\n\t[notification release];\n\t[super dealloc];\n}\n\n- (void)handleInvocation:(NSInvocation *)anInvocation\n{\n\t[[NSNotificationCenter defaultCenter] postNotification:notification];\n}\n\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,6,null,6,6,6,null,null,null,null,6,6,6,null,6,null,6,6,null,null,null]},{"name":"OCMock/OCMObserverRecorder.m","source":"/*\n *  Copyright (c) 2009-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import <objc/runtime.h>\n#import <OCMock/OCMConstraint.h>\n#import \"NSInvocation+OCMAdditions.h\"\n#import \"OCMObserverRecorder.h\"\n\n@interface NSObject(HCMatcherDummy)\n- (BOOL)matches:(id)item;\n@end\n\n#pragma mark -\n\n\n@implementation OCMObserverRecorder\n\n#pragma mark  Initialisers, description, accessors, etc.\n\n- (void)dealloc\n{\n\t[recordedNotification release];\n\t[super dealloc];\n}\n\n\n#pragma mark  Recording\n\n- (void)notificationWithName:(NSString *)name object:(id)sender\n{\n\trecordedNotification = [[NSNotification notificationWithName:name object:sender] retain];\n}\n\n- (void)notificationWithName:(NSString *)name object:(id)sender userInfo:(NSDictionary *)userInfo\n{\n\trecordedNotification = [[NSNotification notificationWithName:name object:sender userInfo:userInfo] retain];\n}\n\n\n#pragma mark  Verification\n\n- (BOOL)matchesNotification:(NSNotification *)aNotification\n{\n\treturn [self argument:[recordedNotification name] matchesArgument:[aNotification name]] &&\n\t[self argument:[recordedNotification object] matchesArgument:[aNotification object]] &&\n\t[self argument:[recordedNotification userInfo] matchesArgument:[aNotification userInfo]];\n}\n\n- (BOOL)argument:(id)expectedArg matchesArgument:(id)observedArg\n{\n\tif([expectedArg isKindOfClass:[OCMConstraint class]])\n\t{\t\n\t\treturn [expectedArg evaluate:observedArg];\n\t}\n\telse if([expectedArg conformsToProtocol:objc_getProtocol(\"HCMatcher\")])\n\t{\n\t\treturn [expectedArg matches:observedArg];\n\t}\n\telse if (expectedArg == observedArg)\n\t{\n\t\treturn YES;\n\t}\n\telse if (expectedArg == nil || observedArg == nil)\n\t{\n\t\treturn NO;\n\t}\n\telse\n\t{\n\t\treturn [expectedArg isEqual:observedArg];\n\t}\n}\n\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,34,34,34,null,null,null,null,30,null,30,30,null,4,null,4,4,null,null,null,null,30,null,80,null,null,30,null,80,null,80,null,14,null,66,null,0,null,66,null,54,null,24,null,0,null,null,null,12,null,80,null,null,null]},{"name":"OCMock/OCMockObject.m","source":"/*\n *  Copyright (c) 2004-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import <OCMock/OCMockObject.h>\n#import \"OCClassMockObject.h\"\n#import \"OCProtocolMockObject.h\"\n#import \"OCPartialMockObject.h\"\n#import \"OCObserverMockObject.h\"\n#import <OCMock/OCMockRecorder.h>\n#import <OCMock/OCMLocation.h>\n#import \"NSInvocation+OCMAdditions.h\"\n#import \"OCMInvocationMatcher.h\"\n#import \"OCMMacroState.h\"\n#import \"OCMFunctions.h\"\n#import \"OCMVerifier.h\"\n\n\n@implementation OCMockObject\n\n#pragma mark  Class initialisation\n\n+ (void)initialize\n{\n\tif([[NSInvocation class] instanceMethodSignatureForSelector:@selector(getArgumentAtIndexAsObject:)] == NULL)\n\t\t[NSException raise:NSInternalInconsistencyException format:@\"** Expected method not present; the method getArgumentAtIndexAsObject: is not implemented by NSInvocation. If you see this exception it is likely that you are using the static library version of OCMock and your project is not configured correctly to load categories from static libraries. Did you forget to add the -ObjC linker flag?\"];\n}\n\n\n#pragma mark  Factory methods\n\n+ (id)mockForClass:(Class)aClass\n{\n\treturn [[[OCClassMockObject alloc] initWithClass:aClass] autorelease];\n}\n\n+ (id)mockForProtocol:(Protocol *)aProtocol\n{\n\treturn [[[OCProtocolMockObject alloc] initWithProtocol:aProtocol] autorelease];\n}\n\n+ (id)partialMockForObject:(NSObject *)anObject\n{\n\treturn [[[OCPartialMockObject alloc] initWithObject:anObject] autorelease];\n}\n\n\n+ (id)niceMockForClass:(Class)aClass\n{\n\treturn [self _makeNice:[self mockForClass:aClass]];\n}\n\n+ (id)niceMockForProtocol:(Protocol *)aProtocol\n{\n\treturn [self _makeNice:[self mockForProtocol:aProtocol]];\n}\n\n\n+ (id)_makeNice:(OCMockObject *)mock\n{\n\tmock->isNice = YES;\n\treturn mock;\n}\n\n\n+ (id)observerMock\n{\n\treturn [[[OCObserverMockObject alloc] init] autorelease];\n}\n\n\n#pragma mark  Initialisers, description, accessors, etc.\n\n- (id)init\n{\n\t// no [super init], we're inheriting from NSProxy\n\texpectationOrderMatters = NO;\n\trecorders = [[NSMutableArray alloc] init];\n\texpectations = [[NSMutableArray alloc] init];\n\trejections = [[NSMutableArray alloc] init];\n\texceptions = [[NSMutableArray alloc] init];\n    invocations = [[NSMutableArray alloc] init];\n    return self;\n}\n\n- (void)dealloc\n{\n\t[recorders release];\n\t[expectations release];\n\t[rejections\trelease];\n\t[exceptions release];\n\t[invocations release];\n\t[super dealloc];\n}\n\n- (NSString *)description\n{\n\treturn @\"OCMockObject\";\n}\n\n\n- (void)setExpectationOrderMatters:(BOOL)flag\n{\n    expectationOrderMatters = flag;\n}\n\n\n#pragma mark  Public API\n\n- (id)stub\n{\n    OCMockRecorder *recorder = [[[OCMockRecorder alloc] initWithMockObject:self] autorelease];\n\t[recorders addObject:recorder];\n\treturn recorder;\n}\n\n\n- (id)expect\n{\n\tOCMockRecorder *recorder = [self stub];\n\t[expectations addObject:recorder];\n\treturn recorder;\n}\n\n\n- (id)reject\n{\n\tOCMockRecorder *recorder = [self stub];\n\t[rejections addObject:recorder];\n\treturn recorder;\n}\n\n\n- (id)verify\n{\n    return [self verifyAtLocation:nil];\n}\n\n- (id)verifyAtLocation:(OCMLocation *)location\n{\n\tif([expectations count] == 1)\n\t{\n        NSString *description = [NSString stringWithFormat:@\"%@: expected method was not invoked: %@\",\n         [self description], [[expectations objectAtIndex:0] description]];\n        OCMReportFailure(location, description);\n\t}\n\telse if([expectations count] > 0)\n\t{\n\t\tNSString *description = [NSString stringWithFormat:@\"%@: %@ expected methods were not invoked: %@\",\n         [self description], @([expectations count]), [self _recorderDescriptions:YES]];\n        OCMReportFailure(location, description);\n\t}\n\tif([exceptions count] > 0)\n\t{\n        NSString *description = [NSString stringWithFormat:@\"%@: %@ (This is a strict mock failure that was ignored when it actually occured.)\",\n         [self description], [[exceptions objectAtIndex:0] description]];\n        OCMReportFailure(location, description);\n\t}\n\n    return [[[OCMVerifier alloc] initWithMockObject:self] autorelease];\n}\n\n\n- (void)verifyWithDelay:(NSTimeInterval)delay\n{\n    [self verifyWithDelay:delay atLocation:nil];\n}\n\n- (void)verifyWithDelay:(NSTimeInterval)delay atLocation:(OCMLocation *)location\n{\n    NSTimeInterval step = 0.01;\n    while(delay > 0)\n    {\n        if([expectations count] == 0)\n            break;\n        [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:step]];\n        delay -= step;\n        step *= 2;\n    }\n    [self verifyAtLocation:location];\n}\n\n- (void)stopMocking\n{\n    // no-op for mock objects that are not class object or partial mocks\n}\n\n\n#pragma mark  Additional setup (called from recorder)\n\n- (void)prepareForMockingClassMethod:(__unused SEL)aSelector\n{\n    // to be overridden by subclasses\n}\n\n- (void)prepareForMockingMethod:(__unused SEL)aSelector\n{\n    // to be overridden by subclasses\n}\n\n\n#pragma mark  Handling invocations\n\n- (BOOL)handleSelector:(SEL)sel\n{\n    for (OCMockRecorder *recorder in recorders)\n        if ([[recorder invocationMatcher] matchesSelector:sel])\n            return YES;\n\n    return NO;\n}\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation\n{\n    OCMMacroState *macroState = [OCMMacroState globalState];\n    if(macroState != nil)\n    {\n        [macroState handleInvocation:anInvocation];\n    }\n    else\n    {\n        if([self handleInvocation:anInvocation] == NO)\n            [self handleUnRecordedInvocation:anInvocation];\n    }\n}\n\n- (BOOL)handleInvocation:(NSInvocation *)anInvocation\n{\n\tOCMockRecorder *recorder = nil;\n\tunsigned int\t\t\t   i;\n\n    [invocations addObject:anInvocation];\n\t\n\tfor(i = 0; i < [recorders count]; i++)\n\t{\n\t\trecorder = [recorders objectAtIndex:i];\n\t\tif([[recorder invocationMatcher] matchesInvocation:anInvocation])\n\t\t\tbreak;\n\t}\n\t\n\tif(i == [recorders count])\n\t\treturn NO;\n\t\n\tif([rejections containsObject:recorder]) \n\t{\n\t\tNSException *exception = [NSException exceptionWithName:NSInternalInconsistencyException reason:\n\t\t\t\t\t\t\t\t  [NSString stringWithFormat:@\"%@: explicitly disallowed method invoked: %@\", [self description], \n\t\t\t\t\t\t\t\t   [anInvocation invocationDescription]] userInfo:nil];\n\t\t[exceptions addObject:exception];\n\t\t[exception raise];\n\t}\n\n\tif([expectations containsObject:recorder])\n\t{\n\t\tif(expectationOrderMatters && ([expectations objectAtIndex:0] != recorder))\n\t\t{\n\t\t\t[NSException raise:NSInternalInconsistencyException\tformat:@\"%@: unexpected method invoked: %@\\n\\texpected:\\t%@\",  \n\t\t\t [self description], [recorder description], [[expectations objectAtIndex:0] description]];\n\t\t\t\n\t\t}\n\t\t[[recorder retain] autorelease];\n\t\t[expectations removeObject:recorder];\n\t\t[recorders removeObjectAtIndex:i];\n\t}\n\t[[recorder invocationHandlers] makeObjectsPerformSelector:@selector(handleInvocation:) withObject:anInvocation];\n\t\n\treturn YES;\n}\n\n- (void)handleUnRecordedInvocation:(NSInvocation *)anInvocation\n{\n\tif(isNice == NO)\n\t{\n\t\tNSException *exception = [NSException exceptionWithName:NSInternalInconsistencyException reason:\n\t\t\t\t\t\t\t\t  [NSString stringWithFormat:@\"%@: unexpected method invoked: %@ %@\",  [self description], \n\t\t\t\t\t\t\t\t   [anInvocation invocationDescription], [self _recorderDescriptions:NO]] userInfo:nil];\n\t\t[exceptions addObject:exception];\n\t\t[exception raise];\n\t}\n}\n\n- (void)doesNotRecognizeSelector:(SEL)aSelector\n{\n    OCMMacroState *macroState = [OCMMacroState globalState];\n     if(macroState != nil)\n     {\n         // we can't do anything clever with the macro state because we must raise an exception here\n         [NSException raise:NSInvalidArgumentException format:@\"%@: Cannot stub/expect/verify method '%@' because no such method exists in the mocked class.\", self, NSStringFromSelector(aSelector)];\n     }\n     else\n     {\n         [super doesNotRecognizeSelector:aSelector];\n     }\n}\n\n#pragma mark  Verify After Run\n\n- (void)verifyInvocation:(OCMInvocationMatcher *)matcher\n{\n    [self verifyInvocation:matcher atLocation:nil];\n}\n\n- (void)verifyInvocation:(OCMInvocationMatcher *)matcher atLocation:(OCMLocation *)location\n{\n    for(NSInvocation *invocation in invocations)\n    {\n        if([matcher matchesInvocation:invocation])\n            return;\n    }\n    NSString *description = [NSString stringWithFormat:@\"%@: Method %@ was not invoked.\",\n     [self description], [matcher description]];\n\n    OCMReportFailure(location, description);\n}\n\n\n#pragma mark  Helper methods\n\n- (NSString *)_recorderDescriptions:(BOOL)onlyExpectations\n{\n\tNSMutableString *outputString = [NSMutableString string];\n\t\n\tOCMockRecorder *currentObject;\n\tNSEnumerator *recorderEnumerator = [recorders objectEnumerator];\n\twhile((currentObject = [recorderEnumerator nextObject]) != nil)\n\t{\n\t\tNSString *prefix;\n\t\t\n\t\tif(onlyExpectations)\n\t\t{\n\t\t\tif(![expectations containsObject:currentObject])\n\t\t\t\tcontinue;\n\t\t\tprefix = @\" \";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ([expectations containsObject:currentObject])\n\t\t\t\tprefix = @\"expected: \";\n\t\t\telse\n\t\t\t\tprefix = @\"stubbed: \";\n\t\t}\n\t\t[outputString appendFormat:@\"\\n\\t%@\\t%@\", prefix, [currentObject description]];\n\t}\n\t\n\treturn outputString;\n}\n\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,8,0,8,null,null,null,null,272,null,272,null,null,28,null,28,null,null,46,null,46,null,null,null,44,null,44,null,null,6,null,6,null,null,null,50,null,50,50,null,null,null,null,null,26,null,null,null,null,null,null,null,null,350,350,350,350,350,350,350,null,null,null,null,340,340,340,340,340,340,340,null,null,null,0,null,null,null,4,null,4,4,null,null,null,null,null,null,280,280,280,null,null,null,null,null,100,100,100,null,null,null,null,null,6,6,6,null,null,null,null,null,56,null,null,70,null,70,null,18,null,18,18,52,null,0,null,0,0,56,null,6,null,6,6,null,52,null,null,null,8,null,8,8,null,10,null,10,58,null,42,4,38,38,38,38,10,10,null,null,null,null,378,null,null,null,null,58,null,null,58,null,220,null,null,220,null,null,null,null,108,null,174,22,120,null,90,108,null,266,null,266,266,null,36,36,null,null,214,62,null,214,null,19290,null,19290,19290,null,19290,null,38960,null,420,420,230,190,null,19290,19060,null,230,null,6,null,null,6,6,6,null,224,null,82,null,2,null,null,2,74,74,74,74,222,null,222,19274,null,50,null,50,null,36,null,null,36,36,36,14,null,6,null,6,6,null,null,2,2,null,null,4,null,0,null,null,null,12,null,12,12,null,22,null,3816,null,1886,16,3752,6,null,null,6,24,null,null,null,null,36,null,36,null,36,36,106,null,34,null,34,null,0,0,0,0,null,null,34,2,null,32,null,34,34,null,36,null,null,null,null]},{"name":"OCMock/OCMockRecorder.m","source":"/*\n *  Copyright (c) 2004-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import <objc/runtime.h>\n#import <OCMock/OCMockRecorder.h>\n#import \"OCClassMockObject.h\"\n#import \"OCMInvocationMatcher.h\"\n#import \"OCMReturnValueProvider.h\"\n#import \"OCMBoxedReturnValueProvider.h\"\n#import \"OCMExceptionReturnValueProvider.h\"\n#import \"OCMIndirectReturnValueProvider.h\"\n#import \"OCMNotificationPoster.h\"\n#import \"OCMBlockCaller.h\"\n#import \"OCMRealObjectForwarder.h\"\n#import \"OCMFunctions.h\"\n\n@interface NSObject(HCMatcherDummy)\n- (BOOL)matches:(id)item;\n@end\n\n#pragma mark  -\n\n\n@implementation OCMockRecorder\n\n#pragma mark  Initialisers, description, accessors, etc.\n\n- (id)initWithMockObject:(OCMockObject *)aMockObject\n{\n\tmockObject = aMockObject;\n    invocationMatcher = [[OCMInvocationMatcher alloc] init];\n\tinvocationHandlers = [[NSMutableArray alloc] init];\n\treturn self;\n}\n\n- (void)dealloc\n{\n    [invocationMatcher release];\n\t[invocationHandlers release];\n\t[super dealloc];\n}\n\n- (NSString *)description\n{\n    return [invocationMatcher description];\n}\n\n- (OCMInvocationMatcher *)invocationMatcher\n{\n    return invocationMatcher;\n}\n\n- (NSArray *)invocationHandlers\n{\n    return invocationHandlers;\n}\n\n\n#pragma mark  Recording invocation handlers\n\n- (void)addInvocationHandler:(id)aHandler\n{\n    [invocationHandlers addObject:aHandler];\n}\n\n- (id)andReturn:(id)anObject\n{\n\t[self addInvocationHandler:[[[OCMReturnValueProvider alloc] initWithValue:anObject] autorelease]];\n\treturn self;\n}\n\n- (id)andReturnValue:(NSValue *)aValue\n{\n\t[self addInvocationHandler:[[[OCMBoxedReturnValueProvider alloc] initWithValue:aValue] autorelease]];\n\treturn self;\n}\n\n- (id)andThrow:(NSException *)anException\n{\n\t[self addInvocationHandler:[[[OCMExceptionReturnValueProvider alloc] initWithValue:anException] autorelease]];\n\treturn self;\n}\n\n- (id)andPost:(NSNotification *)aNotification\n{\n\t[self addInvocationHandler:[[[OCMNotificationPoster alloc] initWithNotification:aNotification] autorelease]];\n\treturn self;\n}\n\n- (id)andCall:(SEL)selector onObject:(id)anObject\n{\n\t[self addInvocationHandler:[[[OCMIndirectReturnValueProvider alloc] initWithProvider:anObject andSelector:selector] autorelease]];\n\treturn self;\n}\n\n- (id)andDo:(void (^)(NSInvocation *))aBlock \n{\n\t[self addInvocationHandler:[[[OCMBlockCaller alloc] initWithCallBlock:aBlock] autorelease]];\n\treturn self;\n}\n\n- (id)andForwardToRealObject\n{\n    [self addInvocationHandler:[[[OCMRealObjectForwarder alloc] init] autorelease]];\n    return self;\n}\n\n\n#pragma mark  Modifying the matcher\n\n- (id)classMethod\n{\n    // should we handle the case where this is called with a mock that isn't a class mock?\n    [invocationMatcher setRecordedAsClassMethod:YES];\n    return self;\n}\n\n- (id)ignoringNonObjectArgs\n{\n    [invocationMatcher setIgnoreNonObjectArgs:YES];\n    return self;\n}\n\n\n#pragma mark  Recording the actual invocation\n\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n{\n    if([invocationMatcher recordedAsClassMethod])\n        return [[(OCClassMockObject *)mockObject mockedClass] methodSignatureForSelector:aSelector];\n    \n    NSMethodSignature *signature = [mockObject methodSignatureForSelector:aSelector];\n    if(signature == nil)\n    {\n        // if we're a working with a class mock and there is a class method, auto-switch\n        if(([object_getClass(mockObject) isSubclassOfClass:[OCClassMockObject class]]) &&\n           ([[(OCClassMockObject *)mockObject mockedClass] respondsToSelector:aSelector]))\n        {\n            [self classMethod];\n            signature = [self methodSignatureForSelector:aSelector];\n        }\n    }\n    return signature;\n}\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation\n{\n    if([invocationMatcher recordedAsClassMethod])\n        [mockObject prepareForMockingClassMethod:[anInvocation selector]];\n    else\n        [mockObject prepareForMockingMethod:[anInvocation selector]];\n//\tif(recordedInvocation != nil)\n//\t\t[NSException raise:NSInternalInconsistencyException format:@\"Recorder received two methods to record.\"];\n\t[anInvocation setTarget:nil];\n    [invocationMatcher setInvocation:anInvocation];\n}\n\n- (void)doesNotRecognizeSelector:(SEL)aSelector\n{\n    [NSException raise:NSInvalidArgumentException format:@\"%@: cannot stub or expect method '%@' because no such method exists in the mocked class.\", mockObject, NSStringFromSelector(aSelector)];\n}\n\n\n@end\n\n\n@implementation OCMockRecorder(Properties)\n\n@dynamic _andReturn;\n\n- (OCMockRecorder *(^)(NSValue *))_andReturn\n{\n    id (^theBlock)(id) = ^ (NSValue *aValue)\n    {\n        if(OCMIsObjectType([aValue objCType]))\n        {\n            NSValue *objValue = nil;\n            [aValue getValue:&objValue];\n            return [self andReturn:objValue];\n        }\n        else\n        {\n            return [self andReturnValue:aValue];\n        }\n    };\n    return [[theBlock copy] autorelease];\n}\n\n\n@dynamic _andThrow;\n\n- (OCMockRecorder *(^)(NSException *))_andThrow\n{\n    id (^theBlock)(id) = ^ (NSException * anException)\n    {\n        return [self andThrow:anException];\n    };\n    return [[theBlock copy] autorelease];\n}\n\n\n@dynamic _andPost;\n\n- (OCMockRecorder *(^)(NSNotification *))_andPost\n{\n    id (^theBlock)(id) = ^ (NSNotification * aNotification)\n    {\n        return [self andPost:aNotification];\n    };\n    return [[theBlock copy] autorelease];\n}\n\n\n@dynamic _andCall;\n\n- (OCMockRecorder *(^)(id, SEL))_andCall\n{\n    id (^theBlock)(id, SEL) = ^ (id anObject, SEL aSelector)\n    {\n        return [self andCall:aSelector onObject:anObject];\n    };\n    return [[theBlock copy] autorelease];\n}\n\n\n@dynamic _andDo;\n\n- (OCMockRecorder *(^)(void (^)(NSInvocation *)))_andDo\n{\n    id (^theBlock)(void (^)(NSInvocation *)) = ^ (void (^ blockToCall)(NSInvocation *))\n    {\n        return [self andDo:blockToCall];\n    };\n    return [[theBlock copy] autorelease];\n}\n\n\n@dynamic _andForwardToRealObject;\n\n- (OCMockRecorder *(^)(void))_andForwardToRealObject\n{\n    id (^theBlock)(void) = ^ (void)\n    {\n        return [self andForwardToRealObject];\n    };\n    return [[theBlock copy] autorelease];\n}\n\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,286,null,286,286,286,286,null,null,null,null,284,284,284,284,null,null,null,56,null,null,null,null,444,null,null,null,null,226,null,null,null,null,null,158,null,158,158,null,96,null,96,96,null,null,16,null,16,16,null,null,6,null,6,6,null,null,6,null,6,6,null,null,8,null,8,8,null,null,6,null,6,6,null,null,null,null,20,20,null,null,null,null,null,null,null,null,58,58,null,null,null,null,4,4,null,null,null,null,null,262,null,262,54,null,208,208,null,null,20,null,null,8,8,8,10,208,262,null,278,null,278,58,null,220,null,null,278,278,278,null,2,null,2,2,null,null,null,null,null,null,null,null,null,null,null,36,18,18,null,12,12,12,null,null,null,6,null,36,18,null,null,null,null,null,null,null,4,2,2,2,2,null,null,null,null,null,null,null,4,2,2,2,2,null,null,null,null,null,null,null,4,2,2,2,2,null,null,null,null,null,null,null,4,2,2,2,2,null,null,null,null,null,null,null,4,2,2,2,2,null,null,null,null]},{"name":"OCMock/OCMPassByRefSetter.m","source":"/*\n *  Copyright (c) 2009-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import \"OCMPassByRefSetter.h\"\n\n\n@implementation OCMPassByRefSetter\n\n- (id)initWithValue:(id)aValue\n{\n\tself = [super init];\n\tvalue = [aValue retain];\n\treturn self;\n}\n\n- (void)dealloc\n{\n\t[value release];\n\t[super dealloc];\n}\n\n- (id)value\n{\n\treturn value;\n}\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,6,null,6,6,6,null,null,null,null,6,6,6,null,null,null,6,null,null,null]},{"name":"OCMock/OCMRealObjectForwarder.m","source":"/*\n *  Copyright (c) 2010-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import <objc/runtime.h>\n#import \"OCPartialMockObject.h\"\n#import \"OCMRealObjectForwarder.h\"\n#import \"OCMFunctions.h\"\n\n\n@implementation OCMRealObjectForwarder\n\n- (void)handleInvocation:(NSInvocation *)anInvocation \n{\n\tid invocationTarget = [anInvocation target];\n\n    [anInvocation setSelector:OCMAliasForOriginalSelector([anInvocation selector])];\n\tif ([invocationTarget isProxy])\n\t{\n\t    if (class_getInstanceMethod([invocationTarget mockObjectClass], @selector(realObject)))\n\t    {\n\t        // the method has been invoked on the mock, we need to change the target to the real object\n\t        [anInvocation setTarget:[(OCPartialMockObject *)invocationTarget realObject]];\n\t    }\n\t    else\n\t    {\n\t        [NSException raise:NSInternalInconsistencyException\n\t                    format:@\"Method andForwardToRealObject can only be used with partial mocks and class methods.\"];\n\t    }\n\t}\n\n\t[anInvocation invoke];\n}\n\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,14,null,14,null,14,14,null,6,null,null,4,4,null,null,2,null,null,4,null,12,12,null,null,null]},{"name":"OCMock/OCMReturnValueProvider.m","source":"/*\n *  Copyright (c) 2009-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import \"NSMethodSignature+OCMAdditions.h\"\n#import \"OCMReturnValueProvider.h\"\n#import \"OCMFunctions.h\"\n\n\n@implementation OCMReturnValueProvider\n\n- (id)initWithValue:(id)aValue\n{\n\tself = [super init];\n\treturnValue = [aValue retain];\n\treturn self;\n}\n\n- (void)dealloc\n{\n\t[returnValue release];\n\t[super dealloc];\n}\n\n- (void)handleInvocation:(NSInvocation *)anInvocation\n{\n    if(!OCMIsObjectType([[anInvocation methodSignature] methodReturnType]))\n    {\n        @throw [NSException exceptionWithName:NSInvalidArgumentException reason:@\"Expected invocation with object return type. Did you mean to use andReturnValue: instead?\" userInfo:nil];\n    }\n    NSString *sel = NSStringFromSelector([anInvocation selector]);\n    if([sel hasPrefix:@\"alloc\"] || [sel hasPrefix:@\"new\"] || [sel hasPrefix:@\"copy\"] || [sel hasPrefix:@\"mutableCopy\"])\n    {\n        // methods that \"create\" an object return it with an extra retain count\n        [returnValue retain];\n    }\n\t[anInvocation setReturnValue:&returnValue];\n}\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,118,null,118,118,118,null,null,null,null,118,118,118,null,84,null,84,null,0,null,84,336,null,null,2,2,84,84,null,null]},{"name":"OCMock/OCMStubMacroState.m","source":"/*\n *  Copyright (c) 2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import \"OCMStubMacroState.h\"\n#import \"OCMockObject.h\"\n#import \"OCMockRecorder.h\"\n\n@implementation OCMStubMacroState\n\n- (void)setShouldRecordExpectation:(BOOL)flag\n{\n    shouldRecordExpectation = flag;\n}\n\n- (OCMockRecorder *)recorder\n{\n    return recorder;\n}\n\n- (void)switchToClassMethod\n{\n    shouldRecordAsClassMethod = YES;\n}\n\n- (BOOL)hasSwitchedToClassMethod\n{\n    return shouldRecordAsClassMethod;\n}\n\n- (void)handleInvocation:(NSInvocation *)anInvocation\n{\n    OCMockObject *mock = [anInvocation target];\n    recorder = shouldRecordExpectation ? [mock expect] : [mock stub];\n    if(shouldRecordAsClassMethod)\n        [recorder classMethod];\n    [recorder forwardInvocation:anInvocation];\n}\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,null,4,4,null,null,null,28,null,null,null,null,4,4,null,null,null,22,null,null,26,null,26,78,26,4,26,26,null,null]},{"name":"OCMock/OCMVerifier.m","source":"/*\n *  Copyright (c) 2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import <objc/runtime.h>\n#import \"OCMVerifier.h\"\n#import \"OCMockObject.h\"\n#import \"OCMInvocationMatcher.h\"\n#import \"OCClassMockObject.h\"\n\n\n@implementation OCMVerifier\n\n- (id)initWithMockObject:(OCMockObject *)aMockObject\n{\n    // no super, we're inheriting from NSProxy\n    mockObject = aMockObject;\n    return self;\n}\n\n- (id)classMethod\n{\n    // should we handle the case where this is called with a mock that isn't a class mock?\n    verifyAsClassMethod = YES;\n    return self;\n}\n\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n{\n    if(verifyAsClassMethod)\n        return [[(OCClassMockObject *)mockObject mockedClass] methodSignatureForSelector:aSelector];\n\n    NSMethodSignature *signature = [mockObject methodSignatureForSelector:aSelector];\n    if(signature == nil)\n    {\n        // if we're a working with a class mock and there is a class method, auto-switch\n        if(([object_getClass(mockObject) isSubclassOfClass:[OCClassMockObject class]]) &&\n           ([[(OCClassMockObject *)mockObject mockedClass] respondsToSelector:aSelector]))\n        {\n            [self classMethod];\n            signature = [self methodSignatureForSelector:aSelector];\n        }\n    }\n    return signature;\n}\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation\n{\n    [anInvocation setTarget:nil];\n    OCMInvocationMatcher *matcher = [[[OCMInvocationMatcher alloc] init] autorelease];\n    [matcher setInvocation:anInvocation];\n    [matcher setRecordedAsClassMethod:verifyAsClassMethod];\n    [mockObject verifyInvocation:matcher];\n}\n\n- (void)doesNotRecognizeSelector:(SEL)aSelector\n{\n    [NSException raise:NSInvalidArgumentException format:@\"%@: cannot stub or expect method '%@' because no such method exists in the mocked class.\", mockObject, NSStringFromSelector(aSelector)];\n}\n\n\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,52,null,null,52,52,null,null,null,null,null,4,4,null,null,16,null,16,4,null,12,12,null,null,8,null,null,4,4,4,4,12,16,null,12,null,12,12,12,12,12,12,null,0,null,0,0,null,null,null,null]},{"name":"OCMock/OCMVerifyMacroState.m","source":"/*\n *  Copyright (c) 2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import \"OCMVerifyMacroState.h\"\n#import \"OCMInvocationMatcher.h\"\n#import \"OCMLocation.h\"\n#import \"OCMockObject.h\"\n\n\n@implementation OCMVerifyMacroState\n\n- (id)initWithLocation:(OCMLocation *)aLocation\n{\n    self = [super init];\n    location = aLocation;\n    return self;\n}\n\n- (void)switchToClassMethod\n{\n    shouldVerifyClassMethod = YES;\n}\n\n- (BOOL)hasSwitchedToClassMethod\n{\n    return shouldVerifyClassMethod;\n}\n\n- (void)handleInvocation:(NSInvocation *)anInvocation\n{\n    OCMockObject *mock = [anInvocation target];\n    [anInvocation setTarget:nil];\n    OCMInvocationMatcher *matcher = [[[OCMInvocationMatcher alloc] init] autorelease];\n    [matcher setRecordedAsClassMethod:shouldVerifyClassMethod];\n    [matcher setInvocation:anInvocation];\n    [mock verifyInvocation:matcher atLocation:location];\n}\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,12,null,12,12,12,null,null,null,null,4,4,null,null,null,12,null,null,10,null,10,10,10,10,10,10,10,null,null]},{"name":"OCMock/OCObserverMockObject.m","source":"/*\n *  Copyright (c) 2009-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import \"OCObserverMockObject.h\"\n#import \"OCMObserverRecorder.h\"\n#import \"OCMLocation.h\"\n#import \"OCMFunctions.h\"\n\n\n@implementation OCObserverMockObject\n\n#pragma mark  Initialisers, description, accessors, etc.\n\n- (id)init\n{\n\tself = [super init];\n\trecorders = [[NSMutableArray alloc] init];\n\tcenters = [[NSMutableArray alloc] init];\n\treturn self;\n}\n\n- (id)retain\n{\n    return [super retain];\n}\n\n- (void)dealloc\n{\n    for(NSNotificationCenter *c in centers)\n        [c removeObserver:self];\n    [centers release];\n\t[recorders release];\n\t[super dealloc];\n}\n\n- (NSString *)description\n{\n\treturn @\"OCMockObserver\";\n}\n\n- (void)setExpectationOrderMatters:(BOOL)flag\n{\n    expectationOrderMatters = flag;\n}\n\n- (void)autoRemoveFromCenter:(NSNotificationCenter *)aCenter\n{\n    [centers addObject:aCenter];\n}\n\n\n#pragma mark  Public API\n\n- (id)expect\n{\n\tOCMObserverRecorder *recorder = [[[OCMObserverRecorder alloc] init] autorelease];\n\t[recorders addObject:recorder];\n\treturn recorder;\n}\n\n- (void)verify\n{\n    [self verifyAtLocation:nil];\n}\n\n- (void)verifyAtLocation:(OCMLocation *)location\n{\n    if([recorders count] == 1)\n    {\n        NSString *description = [NSString stringWithFormat:@\"%@: expected notification was not observed: %@\",\n         [self description], [[recorders lastObject] description]];\n        OCMReportFailure(location, description);\n    }\n    else if([recorders count] > 0)\n    {\n        NSString *description = [NSString stringWithFormat:@\"%@ : %@ expected notifications were not observed.\",\n         [self description], @([recorders count])];\n        OCMReportFailure(location, description);\n    }\n}\n\n\n#pragma mark  Receiving recording requests via macro\n\n- (void)notificationWithName:(NSString *)name object:(id)sender\n{\n    [[self expect] notificationWithName:name object:sender];\n}\n\n\n#pragma mark  Receiving notifications\n\n- (void)handleNotification:(NSNotification *)aNotification\n{\n\tNSUInteger i, limit;\n\t\n\tlimit = expectationOrderMatters ? 1 : [recorders count];\n\tfor(i = 0; i < limit; i++)\n\t{\n\t\tif([[recorders objectAtIndex:i] matchesNotification:aNotification])\n\t\t{\n\t\t\t[recorders removeObjectAtIndex:i];\n\t\t\treturn;\n\t\t}\n\t}\n\t[NSException raise:NSInternalInconsistencyException format:@\"%@: unexpected notification observed: %@\", [self description], \n\t  [aNotification description]];\n}\n\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,26,26,26,26,null,null,null,null,0,null,null,null,null,104,104,26,26,26,26,null,null,null,14,null,null,4,null,4,4,null,26,null,26,26,null,null,null,null,null,null,34,34,34,null,null,null,null,10,10,null,12,null,12,null,4,null,4,4,8,null,0,null,0,0,8,null,null,null,null,2,null,2,2,null,null,null,null,30,null,30,null,90,80,null,30,null,20,20,null,10,10,null,30,null,null,null]},{"name":"OCMock/OCPartialMockObject.m","source":"/*\n *  Copyright (c) 2009-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import <objc/runtime.h>\n#import \"OCMockObject.h\"\n#import \"OCPartialMockObject.h\"\n#import \"NSMethodSignature+OCMAdditions.h\"\n#import \"NSObject+OCMAdditions.h\"\n#import \"OCMFunctions.h\"\n\n\n@implementation OCPartialMockObject\n\n#pragma mark  Initialisers, description, accessors, etc.\n\n- (id)initWithObject:(NSObject *)anObject\n{\n    [self assertClassIsSupported:[anObject class]];\n\t[super initWithClass:[anObject class]];\n\trealObject = [anObject retain];\n    [self prepareObjectForInstanceMethodMocking];\n\treturn self;\n}\n\n- (void)dealloc\n{\n\t[self stopMocking];\n\t[super dealloc];\n}\n\n- (NSString *)description\n{\n\treturn [NSString stringWithFormat:@\"OCPartialMockObject[%@]\", NSStringFromClass(mockedClass)];\n}\n\n- (NSObject *)realObject\n{\n\treturn realObject;\n}\n\n#pragma mark  Helper methods\n\n- (void)assertClassIsSupported:(Class)class\n{\n    NSString *classname = NSStringFromClass(class);\n    NSString *reason = nil;\n    if([classname hasPrefix:@\"__NSTagged\"])\n        reason = [NSString stringWithFormat:@\"OCMock does not support partially mocking tagged classes; got %@\", classname];\n    else if([classname hasPrefix:@\"__NSCF\"])\n        reason = [NSString stringWithFormat:@\"OCMock does not support partially mocking toll-free bridged classes; got %@\", classname];\n\n    if(reason != nil)\n        [[NSException exceptionWithName:NSInvalidArgumentException reason:reason userInfo:nil] raise];\n}\n\n\n#pragma mark  Extending/overriding superclass behaviour\n\n- (void)stopMocking\n{\n    if(realObject != nil)\n    {\n        OCMSetAssociatedMockForObject(nil, realObject);\n        object_setClass(realObject, [self mockedClass]);\n        [realObject release];\n        realObject = nil;\n    }\n    [super stopMocking];\n}\n\n- (void)handleUnRecordedInvocation:(NSInvocation *)anInvocation\n{\n\t[anInvocation invokeWithTarget:realObject];\n}\n\n\n#pragma mark  Subclass management\n\n- (void)prepareObjectForInstanceMethodMocking\n{\n    OCMSetAssociatedMockForObject(self, realObject);\n\n    /* dynamically create a subclass and set it as the class of the object */\n    Class subclass = OCMCreateSubclass(mockedClass, realObject);\n\tobject_setClass(realObject, subclass);\n\n    /* point forwardInvocation: of the object to the implementation in the mock */\n\tMethod myForwardMethod = class_getInstanceMethod([self mockObjectClass], @selector(forwardInvocationForRealObject:));\n\tIMP myForwardIMP = method_getImplementation(myForwardMethod);\n    class_addMethod(subclass, @selector(forwardInvocation:), myForwardIMP, method_getTypeEncoding(myForwardMethod));\n\n    /* do the same for forwardingTargetForSelector, remember existing imp with alias selector */\n    Method myForwardingTargetMethod = class_getInstanceMethod([self mockObjectClass], @selector(forwardingTargetForSelectorForRealObject:));\n    IMP myForwardingTargetIMP = method_getImplementation(myForwardingTargetMethod);\n    IMP originalForwardingTargetIMP = [mockedClass instanceMethodForSelector:@selector(forwardingTargetForSelector:)];\n    class_addMethod(subclass, @selector(forwardingTargetForSelector:), myForwardingTargetIMP, method_getTypeEncoding(myForwardingTargetMethod));\n    class_addMethod(subclass, @selector(ocmock_replaced_forwardingTargetForSelector:), originalForwardingTargetIMP, method_getTypeEncoding(myForwardingTargetMethod));\n\n    /* We also override the -class method to return the original class */\n    Method myObjectClassMethod = class_getInstanceMethod([self mockObjectClass], @selector(classForRealObject));\n    const char *objectClassTypes = method_getTypeEncoding(myObjectClassMethod);\n    IMP myObjectClassImp = method_getImplementation(myObjectClassMethod);\n    class_addMethod(subclass, @selector(class), myObjectClassImp, objectClassTypes);\n\n    /* Adding forwarder for all instance methods to allow for verify after run */\n    NSArray *whiteList = @[@\"class\", @\"forwardingTargetForSelector:\", @\"methodSignatureForSelector:\", @\"forwardInvocation:\"];\n    [NSObject enumerateMethodsInClass:mockedClass usingBlock:^(SEL selector) {\n        if(![whiteList containsObject:NSStringFromSelector(selector)])\n            [self setupForwarderForSelector:selector];\n    }];\n}\n\n- (void)setupForwarderForSelector:(SEL)selector\n{\n    Method originalMethod = class_getInstanceMethod(mockedClass, selector);\n\tIMP originalIMP = method_getImplementation(originalMethod);\n    const char *types = method_getTypeEncoding(originalMethod);\n    /* Might be NULL if the selector is forwarded to another class */\n    // TODO: check the fallback implementation is actually sufficient\n    if(types == NULL)\n        types = ([[mockedClass instanceMethodSignatureForSelector:selector] fullObjCTypes]);\n\n    Class subclass = object_getClass([self realObject]);\n    IMP forwarderIMP = [subclass instanceMethodForwarderForSelector:selector];\n    class_replaceMethod(subclass, selector, forwarderIMP, types);\n\tSEL aliasSelector = OCMAliasForOriginalSelector(selector);\n\tclass_addMethod(subclass, aliasSelector, originalIMP, types);\n}\n\n\n// Implementation of the -class method; return the Class that was reported with [realObject class] prior to mocking\n- (Class)classForRealObject\n{\n    // in here \"self\" is a reference to the real object, not the mock\n    OCPartialMockObject *mock = OCMGetAssociatedMockForObject(self);\n    if(mock == nil)\n        [NSException raise:NSInternalInconsistencyException format:@\"No partial mock for object %p\", self];\n    return [mock mockedClass];\n}\n\n\n- (id)forwardingTargetForSelectorForRealObject:(SEL)sel\n{\n\t// in here \"self\" is a reference to the real object, not the mock\n    OCPartialMockObject *mock = OCMGetAssociatedMockForObject(self);\n    if(mock == nil)\n        [NSException raise:NSInternalInconsistencyException format:@\"No partial mock for object %p\", self];\n    if([mock handleSelector:sel])\n        return self;\n\n    return [self ocmock_replaced_forwardingTargetForSelector:sel];\n}\n\n//  Make the compiler happy in -forwardingTargetForSelectorForRealObject: because it can't find the message\n- (id)ocmock_replaced_forwardingTargetForSelector:(SEL)sel\n{\n    return nil;\n}\n\n\n- (void)forwardInvocationForRealObject:(NSInvocation *)anInvocation\n{\n\t// in here \"self\" is a reference to the real object, not the mock\n    OCPartialMockObject *mock = OCMGetAssociatedMockForObject(self);\n    if(mock == nil)\n        [NSException raise:NSInternalInconsistencyException format:@\"No partial mock for object %p\", self];\n\n\tif([mock handleInvocation:anInvocation] == NO)\n    {\n        [anInvocation setSelector:OCMAliasForOriginalSelector([anInvocation selector])];\n        [anInvocation invoke];\n    }\n}\n\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,46,null,46,46,46,46,46,null,null,null,null,42,42,42,null,null,null,10,null,null,null,null,9016,null,null,null,null,46,null,46,46,46,2,44,2,null,46,4,42,null,null,null,null,null,null,94,null,40,40,40,40,40,94,94,null,12,null,12,12,null,null,null,null,null,null,42,null,null,42,42,null,null,42,42,42,null,null,42,42,42,42,42,null,null,42,42,42,42,null,null,9258,9258,9216,9012,9216,42,null,9012,null,9012,9012,9012,null,null,9012,0,null,9012,9012,9012,9012,9012,9012,null,null,null,null,null,null,96,96,0,96,null,null,null,108,null,null,108,108,0,108,18,null,90,108,null,null,0,null,0,null,null,null,108,null,null,108,108,0,null,108,null,90,90,90,108,null,null,null]},{"name":"OCMock/OCProtocolMockObject.m","source":"/*\n *  Copyright (c) 2005-2014 Erik Doernenburg and contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use these files except in compliance with the License. You may obtain\n *  a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations\n *  under the License.\n */\n\n#import <objc/runtime.h>\n#import \"NSMethodSignature+OCMAdditions.h\"\n#import \"OCProtocolMockObject.h\"\n\n@implementation OCProtocolMockObject\n\n#pragma mark  Initialisers, description, accessors, etc.\n\n- (id)initWithProtocol:(Protocol *)aProtocol\n{\n\t[super init];\n\tmockedProtocol = aProtocol;\n\treturn self;\n}\n\n- (NSString *)description\n{\n    const char* name = protocol_getName(mockedProtocol);\n    return [NSString stringWithFormat:@\"OCMockObject[%s]\", name];\n}\n\n#pragma mark  Proxy API\n\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n{\n\tstruct objc_method_description methodDescription = protocol_getMethodDescription(mockedProtocol, aSelector, YES, YES);\n    if(methodDescription.name == NULL) \n\t{\n        methodDescription = protocol_getMethodDescription(mockedProtocol, aSelector, NO, YES);\n    }\n    if(methodDescription.name == NULL) \n\t{\n        return nil;\n    }\n\treturn [NSMethodSignature signatureWithObjCTypes:methodDescription.types];\n}\n\n- (BOOL)conformsToProtocol:(Protocol *)aProtocol\n{\n    return protocol_conformsToProtocol(mockedProtocol, aProtocol);\n}\n\n- (BOOL)respondsToSelector:(SEL)selector\n{\n    return ([self methodSignatureForSelector:selector] != nil);\n}\n\n@end\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,28,null,28,28,28,null,null,null,null,4,4,null,null,null,null,36,null,36,36,null,6,6,36,null,4,null,32,36,null,2,null,2,null,null,6,null,6,null,null,null]}]}